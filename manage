#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["rich", "argparse", "argcomplete", "pyyaml"]
# ///
import subprocess
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional, Any
import re
from rich.console import Console
from rich.panel import Panel
import argparse
import argcomplete
import yaml
import hashlib

console = Console()

def class_name_to_snake_case(class_name: str) -> str:
    """Convert UpperCamelCase class name to snake_case command name."""
    # Remove 'Command' suffix if present
    if class_name.endswith('Command'):
        class_name = class_name[:-7]
    
    # Convert UpperCamelCase to snake_case
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', class_name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

@dataclass
class CommandConfig:
    """Configuration for a command including its parameters and validation."""
    description: str
    name: str = ""
    required_args: List[str] = None
    optional_args: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.required_args is None:
            self.required_args = []
        if self.optional_args is None:
            self.optional_args = {}


class BaseCommand(ABC):
    """Base class for all commands."""
    
    def __init__(self, config: CommandConfig):
        self.config = config
    
    @abstractmethod
    def execute(self, **kwargs) -> None:
        """Execute the command with the given arguments."""
        pass
    
    def validate_args(self, args: Dict[str, Any]) -> bool:
        """Validate that required arguments are present."""
        for req_arg in self.config.required_args:
            if not args.get(req_arg):
                console.print(f"[red]Error: --{req_arg} is required for {self.config.name}[/red]")
                return False
        return True


class SystemExecutor:
    """Handles system command execution with rich formatting."""
    
    @staticmethod
    def run_command(command: str, description: Optional[str] = None) -> subprocess.CompletedProcess:
        """Run a shell command and display its output with rich formatting."""
        if description:
            console.print(Panel(f"[bold blue]{description}[/bold blue]"))
        try:
            result = subprocess.run(command, shell=True, text=True, check=True, capture_output=True)
            if result.stdout and result.stdout.strip():
                console.print(Panel(f"[green]{result.stdout.strip()}[/green]"))
            if result.stderr and result.stderr.strip():
                console.print(Panel(f"[yellow]{result.stderr.strip()}[/yellow]"))
            return result
        except subprocess.CalledProcessError as e:
            if e.stderr and e.stderr.strip():
                console.print(Panel(f"[red]{e.stderr.strip()}[/red]"))
            raise


class AnsibleCommand(BaseCommand):
    """Base class for Ansible playbook commands."""
    
    def run_ansible_playbook(self, playbook_path: str) -> None:
        """Run an ansible-playbook command."""
        command = f"uvx --from=ansible.core ansible-playbook -i metal/inventory/hosts --extra-vars 'metal/@vars.secrets.yml' {playbook_path}"
        SystemExecutor.run_command(command, description="Running ansible-playbook")


class SetupDnsServerCommand(AnsibleCommand):
    """Command to setup DNS server."""
    
    def execute(self, **kwargs) -> None:
        self.run_ansible_playbook("metal/setup_dns_server.yml")


class SetupNebulaClusterCommand(AnsibleCommand):
    """Command to setup Nebula cluster."""
    
    def execute(self, **kwargs) -> None:
        self.run_ansible_playbook("metal/setup_nebula_cluster.yml")


class SshCommand(BaseCommand):
    """Command to SSH into a host."""
    
    def execute(self, host: str, args: List[str] = None, **kwargs) -> None:
        if args is None:
            args = []
        command = f"ssh -i keys/astro_id_rsa -o StrictHostKeyChecking=no astro@{host} {' '.join(args)}"
        SystemExecutor.run_command(command, description=f"SSH to {host}")


class DeployCommand(BaseCommand):
    """Command to deploy a service to a host."""
    
    def execute(self, service: str, host: str = "nebula01.local", **kwargs) -> None:
        ssh_base = f"ssh -i keys/astro_id_rsa -o StrictHostKeyChecking=no astro@{host}"
        
        # Read compose file to check for external networks
        compose_file_path = f"./services/{service}/compose.yml"
        external_networks = []
        try:
            with open(compose_file_path, 'r') as f:
                compose_data = yaml.safe_load(f)
            networks = compose_data.get('networks', {})
            for network_name, network_config in networks.items():
                if network_config and network_config.get('external', False):
                    external_networks.append(network_name)
        except FileNotFoundError:
            console.print(f"[yellow]Warning: compose.yml not found at {compose_file_path}[/yellow]")
        except Exception as e:
            console.print(f"[yellow]Warning: Could not parse compose.yml: {e}[/yellow]")

        commands = [
            (f"{ssh_base} 'sudo mkdir -p /services/{service} && sudo chown -R astro:users /services'",
             f"Creating service directory on {host}"),
            (f'rsync -avhH --delete -e "ssh -i keys/astro_id_rsa -o StrictHostKeyChecking=no" ./services/{service}/ astro@{host}:/services/{service}',
             f"Syncing service files to {host}")
        ]
        
        # Create external networks if they don't exist
        for network in external_networks:
            commands.append((
            f"{ssh_base} 'sudo docker network inspect {network} >/dev/null 2>&1 || sudo docker network create --driver overlay --attachable {network}'",
            f"Creating external network {network} if it doesn't exist"
            ))
        
        commands.append((
            f"{ssh_base} 'cd /services/{service} && sudo docker stack deploy -c compose.yml {service.split('/')[-1]}'",
            f"Starting service {service} on {host}"
        ))

        for command, description in commands:
            SystemExecutor.run_command(command, description)


class SecretsDeployCommand(BaseCommand):
    """Command to deploy secrets to a host."""
    
    def execute(self, host: str = "nebula01.local", delete: bool = False, **kwargs) -> None:
        # Read secrets from file
        try:
            with open('services/secrets.yml', 'r') as f:
                secrets = yaml.safe_load(f)
        except FileNotFoundError:
            console.print("[red]Error: services/secrets.yml not found[/red]")
            return

        ssh_base = f"ssh -i keys/astro_id_rsa -o StrictHostKeyChecking=no astro@{host}"

        # Get existing secrets
        existing_secrets_result = subprocess.run(
            f"{ssh_base} 'sudo docker secret ls --format \"{{{{.Name}}}}\"'",
            shell=True, text=True, capture_output=True
        )
        existing_secrets = set(existing_secrets_result.stdout.strip().split('\n')) if existing_secrets_result.stdout.strip() else set()

        for secret_name, secret_value in secrets.items():
            secret_hash = hashlib.sha256(str(secret_value).encode()).hexdigest()[:8]
            
            if secret_name in existing_secrets:
                console.print(f"[yellow]Secret {secret_name} exists.[/yellow]")
                continue
            else:
                # Create new secret
                SystemExecutor.run_command(
                    f"echo '{secret_value}' | {ssh_base} 'sudo docker secret create {secret_name} -'",
                    f"Creating new secret {secret_name}"
                )
        
        for secret_name in existing_secrets:
            if secret_name not in secrets:
                # Delete secret if it is not in the new list
                SystemExecutor.run_command(
                    f"{ssh_base} 'sudo docker secret rm {secret_name}'",
                    f"Deleting secret {secret_name}"
                )

        command = f"ssh -i keys/astro_id_rsa -o StrictHostKeyChecking=no astro@{host} sudo docker secret ls"
        SystemExecutor.run_command(command, description=f"Deploying secrets to {host}")


class CommandRegistry:
    """Registry for managing available commands."""
    
    def __init__(self):
        self.commands: Dict[str, BaseCommand] = {}
        self._register_default_commands()
    
    def _register_default_commands(self) -> None:
        """Register all default commands."""
        commands = [
            (SetupDnsServerCommand, CommandConfig(
                description="Setup DNS server using Ansible playbook"
            )),
            (SetupNebulaClusterCommand, CommandConfig(
                description="Setup Nebula cluster using Ansible playbook"
            )),
            (SshCommand, CommandConfig(
                description="SSH into a host",
                required_args=["host"]
            )),
            (DeployCommand, CommandConfig(
                description="Deploy a service to a host",
                required_args=["service"],
                optional_args={"host": "nebula01.local"}
            )),
            (SecretsDeployCommand, CommandConfig(
                description="Deploy secrets to a host",
                optional_args={"host": "nebula01.local"}
            ))
        ]
        
        for command_class, config in commands:
            # Derive name from class name
            config.name = class_name_to_snake_case(command_class.__name__)
            self.register_command(command_class(config))
    
    def register_command(self, command: BaseCommand) -> None:
        """Register a new command."""
        self.commands[command.config.name] = command
    
    def get_command(self, name: str) -> Optional[BaseCommand]:
        """Get a command by name."""
        return self.commands.get(name)
    
    def get_command_names(self) -> List[str]:
        """Get all registered command names."""
        return list(self.commands.keys())
    
    def execute_command(self, name: str, args: Dict[str, Any]) -> None:
        """Execute a command with validation."""
        command = self.get_command(name)
        if not command:
            console.print(f"[red]Unknown command: {name}[/red]")
            return
        
        if not command.validate_args(args):
            return
        
        # Add default values for optional args
        for arg_name, default_value in command.config.optional_args.items():
            if args.get(arg_name) is None:
                args[arg_name] = default_value
        
        command.execute(**args)


def create_parser(registry: CommandRegistry) -> argparse.ArgumentParser:
    """Create the argument parser with commands from registry."""
    parser = argparse.ArgumentParser(description="YAMLotops Management Tool")
    parser.add_argument("command", choices=registry.get_command_names(),
                       help="The command to execute")
    parser.add_argument("--host", help="Host for SSH or deployment commands")
    parser.add_argument("--service", help="Service name for deployment")
    parser.add_argument("args", nargs="*", help="Additional arguments for the command")
    
    return parser


def main():
    """Main entry point."""
    registry = CommandRegistry()
    parser = create_parser(registry)
    
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    
    # Convert parsed args to dict for command execution
    command_args = {
        "host": args.host,
        "service": args.service,
        "args": args.args
    }
    
    registry.execute_command(args.command, command_args)


if __name__ == "__main__":
    main()
